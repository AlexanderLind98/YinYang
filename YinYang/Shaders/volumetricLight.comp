// volumetricLight.comp Compute shader for volumetric lighting via raymarching and depth occlusion.
#version 430 core

// 

layout(local_size_x = 8, local_size_y = 8) in;

// Output image the compute shader writes to
layout(rgba16f, binding = 0) writeonly uniform image2D volumetricOutput;
// Depth texture from the main scene rendering (used to occlude rays)
uniform sampler2D depthMap;

// Matrix to convert from clip space to world space
uniform mat4 inverseViewProjection;
// Matrix to convert from world space to clip space (proj * view)
uniform mat4 viewProjection;
// Matrix to convert from world space to view space (view)
uniform mat4 view;


// Camera position in world space
uniform vec3 cameraPos;
// Sun direction (normalized), in world space
uniform vec3 lightDir;
// Color/intensity of the sun
uniform vec3 lightColor;

// Parameters controlling scattering falloff and step resolution
uniform float density;
uniform float scatteringStrength;
uniform int stepCount;

// Camera frustum range, for linear depth conversion
uniform float nearPlane;
uniform float farPlane;

// Converts non-linear depth from depth map to linear depth in view space
float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Convert from [0..1] to [-1..1] NDC
    return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
}

// Generates pseudo-random jitter based on UV to avoid marching banding artifacts. 
// Maching banding is when object seen as repeated itself in steps instead of smooth.
float Rand(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

/*
// Main compute shader function
void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(volumetricOutput);
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(resolution);

    vec4 clip = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
    vec4 worldPos4 = clip * inverseViewProjection;
    //vec4 worldPos4 = inverseViewProjection *clip;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;

    vec3 rayDir = normalize(worldPos - cameraPos);

    float jitter = Rand(uv);
    float tMax = 50.0;
    float stepSize = tMax / float(stepCount);
    vec3 scattering = vec3(0.0);

    for (int i = 0; i < stepCount; ++i)
    {
        float t = (float(i) + jitter) * stepSize;
        vec3 pos = cameraPos + rayDir * t;

        vec4 clipPos = vec4(pos, 1.0) * viewProjection;
        vec2 sampleUV = (clipPos.xy / clipPos.w) * 0.5 + 0.5;

        if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0)
            continue;

        float sceneDepth = texture(depthMap, sampleUV).r;
        float linearSceneZ = LinearizeDepth(sceneDepth);

        
        float rayZ = -((vec4(pos, 1.0) * view).z);

        if (rayZ > linearSceneZ)
            break;

        float phase = max(dot(rayDir, -lightDir), 0.0);
        float attenuation = exp(-density * t);
        scattering += phase * attenuation * lightColor * scatteringStrength * stepSize;

        if (attenuation * scatteringStrength < 0.001)
            break;
    }

    imageStore(volumetricOutput, pixelCoord, vec4(scattering, 1.0));
}
*/

/*
void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(volumetricOutput);
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(resolution);

    // Clip → World
    vec4 clip = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
    vec4 worldPos4 = clip * inverseViewProjection;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;

    vec3 rayDir = normalize(worldPos - cameraPos);

    // March fremad langs ray
    float t = 10.0;
    vec3 samplePos = cameraPos + rayDir * t;

    // Project sample til clip space
    vec4 clipPos = vec4(samplePos, 1.0) * viewProjection;
    vec2 sampleUV = (clipPos.xy / clipPos.w) * 0.5 + 0.5;

    // Sammenlign depth i clip space (begge i [0..1])
    float sceneDepth = texture(depthMap, sampleUV).r;
    float rayDepth = (clipPos.z / clipPos.w) * 0.5 + 0.5;

    // Debug visualisering: forskel
    float diff = abs(rayDepth - sceneDepth);
    imageStore(volumetricOutput, pixelCoord, vec4(vec3(diff), 1.0));
}


void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(volumetricOutput);
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(resolution);

    // ✅ CORRECT MULTIPLICATION ORDER
    vec4 clip = vec4(uv * 2.0 - 1.0, 0.0, 1.0);
    vec4 worldPos4 = inverseViewProjection * clip;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;

    vec3 rayDir = normalize(worldPos - cameraPos);

    float t = 10.0;
    vec3 pos = cameraPos + rayDir * t;

    vec4 clipPos = vec4(pos, 1.0) * viewProjection;
    vec2 sampleUV = (clipPos.xy / clipPos.w) * 0.5 + 0.5;

    float sceneDepth = texture(depthMap, sampleUV).r;

    float z = sceneDepth * 2.0 - 1.0;
    float viewSpaceZ = (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));

    float rayZ = -((vec4(pos, 1.0) * view).z);

    float diff = abs(rayZ - viewSpaceZ) / 50.0;
    imageStore(volumetricOutput, pixelCoord, vec4(diff));
}
*/

void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(imageSize(volumetricOutput));

    float d = texture(depthMap, uv).r;
    imageStore(volumetricOutput, pixelCoord, vec4(d, d, d, 1.0));
}






// debugs

// //output red if pass can write to image
// imageStore(volumetricOutput, pixelCoord, vec4(1.0, 0.0, 0.0, 1.0));


// //red if there is info in texture
// if (pixelCoord.x < resolution.x / 8 && pixelCoord.y < resolution.y / 8)
//     imageStore(volumetricOutput, pixelCoord, vec4(1.0, 0.0, 0.0, 1.0));
// else
//     imageStore(volumetricOutput, pixelCoord, vec4(scattering, 1.0));

// // grey scale dot(rayDir, -lightDir) 
// float phase = max(dot(rayDir, -lightDir), 0.0);
// imageStore(volumetricOutput, pixelCoord, vec4(phase));


// //greyscale scene depth 
// float d = texture(depthMap, sampleUV).r;
// imageStore(volumetricOutput, pixelCoord, vec4(d, d, d, 1.0));

// // grey scale steps
// float gray = float(i) / float(stepCount);
// imageStore(volumetricOutput, pixelCoord, vec4(gray));

// // no phase or attenuation
// scattering += lightColor * scatteringStrength * stepSize;
