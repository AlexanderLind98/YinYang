#version 460 core

// Thread group size: 8x8 threads per workgroup
layout (local_size_x = 8, local_size_y = 8) in;

// Final volumetric scattering result will be written to this RGBA16F image
layout (rgba16f, binding = 0) writeonly uniform image2D outVolTex;

// Depth texture from shadow map, used for occlusion in light space
uniform sampler2D depthMap;

// Matrces for transformations

// Transforms NDC coordinates back to world space
uniform mat4 inverseViewProjection;

// Transforms world-space positions into the directional light's projection space
uniform mat4 lightSpaceMatrix;


// cam and ligtht parameters
uniform vec3 cameraPos;
uniform vec3 lightDir;
uniform vec3 lightColor;


// raymarch parameters
uniform float density;
uniform float scatteringStrength;
uniform int stepCount;

// Near and far clipping planes of the camera (needed to scale raymarching step)
uniform float nearPlane;
uniform float farPlane;


void main()
{
    // Get the pixel coordinates of this thread
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);

    // Get the resolution of the output texture
    ivec2 sz = imageSize(outVolTex);

    // Convert pixel coordinates to normalized UV coordinates in [0, 1]
    // Add 0.5 to address the pixel center
    vec2 uv = (vec2(pix) + 0.5) / vec2(sz);
 
    // Build an NDC position at the near plane (Z = 0.0), in range [-1, 1]
    vec4 clipNear = vec4(uv * 2.0 - 1.0, 0.0, 1.0);

    // Transform clipNear to world space using the inverse view-projection matrix
    vec4 worldNearH = clipNear * inverseViewProjection;
    worldNearH.xyz /= worldNearH.w;

    // Repeat for far plane (Z = 1.0)
    vec4 clipFar = vec4(uv * 2.0 - 1.0, 1.0, 1.0);
    vec4 worldFarH = clipFar * inverseViewProjection;
    worldFarH.xyz /= worldFarH.w;

    // Calculate normalized ray direction from near to far point in world space
    vec3 rayDir = normalize(worldFarH.xyz - worldNearH.xyz);

    // Set starting point for raymarching at the near-plane world-space position
    vec3 rayStart = worldNearH.xyz;

    // calculate the distance between each raymarching sample
    float tStep = (farPlane - nearPlane) / float(stepCount);

    // current position along the ray
    float tCurr = nearPlane;

    // accumulated light scattering result
    vec3 accum = vec3(0.0);

    // iterate over the number of raymarching steps
    for (int i = 0; i < stepCount; ++i)
    {
        // Sample world-space position along the ray
        vec3 pos = rayStart + rayDir * tCurr;

        // Transform world position into light-space coordinates (shadow map projection)
        vec4 lsH = vec4(pos, 1.0) * lightSpaceMatrix;
        lsH.xyz /= lsH.w;

        // Convert from NDC [-1, 1] to UV [0, 1] to access the depth map
        vec2 shadowUV = lsH.xy * 0.5 + 0.5;

        float vis = 0.0;

        // Only sample the depth map if we're inside the light's shadow map bounds
        if (all(greaterThanEqual(shadowUV, vec2(0.0))) && all(lessThanEqual(shadowUV, vec2(1.0))))
        {
            // Read stored scene depth from the depth texture at this UV
            float sceneDepth = texture(depthMap, shadowUV).r;

            // Normalize the light-space depth to [0, 1] to match the depth map
            float litDepth = lsH.z * 0.5 + 0.5;

            // If the current point is closer to the light than what's in the depth map, it's visible
            vis = litDepth <= sceneDepth ? 1.0 : 0.0;
        }


        // Dot product gives the cosine of the angle between light and view ray (for phase function)
        float phase = max(dot(lightDir, rayDir), 0.0);

        // Combine all scattering terms into a single scalar factor
        float scatter = density * scatteringStrength * phase * vis;

        // Accumulate scattered light, weighted by light color
        accum += scatter * lightColor;

        // Advance to next raymarch sample point
        tCurr += tStep;
    }

    // Average the accumulated scattering over the number of steps for stability
    vec3 color = accum / float(stepCount);

    // Write the computed color into the output texture
    imageStore(outVolTex, pix, vec4(color, 1.0));
}
